###DEVELOPER:Zeqin Lu, zqlu@ece.ubc.ca, University of British Columbia 
switchtolayout;
deleteall;
importnetlist('/Users/lukasc/Documents/GitHub/SiEPIC-Tools/PythonLumericalTools/lumerical/../MZI/MZI_main.spi');
addproperty("::Root Element", "wafer_uniformity_thickness", "wafer", "Matrix");
addproperty("::Root Element", "wafer_uniformity_width", "wafer", "Matrix");
addproperty("::Root Element", "N", "wafer", "Number");
addproperty("::Root Element", "selected_die", "wafer", "Number");
addproperty("::Root Element", "wafer_length", "wafer", "Number");
addproperty("::Root Element::MZI", "MC_uniformity_thickness", "wafer", "Matrix");
addproperty("::Root Element::MZI", "MC_uniformity_width", "wafer", "Matrix");
addproperty("::Root Element::MZI", "MC_grid", "wafer", "Number");
addproperty("::Root Element::MZI", "MC_resolution_x", "wafer", "Number");
addproperty("::Root Element::MZI", "MC_resolution_y", "wafer", "Number");
addproperty("::Root Element::MZI", "MC_non_uniform", "wafer", "Number");
select("::Root Element::MZI");
set("MC_non_uniform",99);
n_wafer = 1;  
n_die = 3;  
kk = 1;  
select("ONA_1");
num_points = get("number of points");
mc1 = matrixdataset("mc1"); # initialize visualizer data, mc1 
Gain_Data_input1 = matrix(num_points,n_wafer*n_die);  
#Run Monte Carlo simulations; 
for (jj=1; jj<=n_wafer; jj=jj+1) {   
 wafer_length = 0.1;  
 wafer_cl_width = 0.0045;  
 wafer_cl_thickness = 0.0045;  
 wafer_clx_width = wafer_cl_width;  
 wafer_cly_width = wafer_cl_width; 
 wafer_clx_thickness = wafer_cl_thickness;  
 wafer_cly_thickness = wafer_cl_thickness; 
 N = 500;  
 wafer_grid=wafer_length/N; 
 wafer_RMS_w = 5.0;     
 wafer_RMS_t = 2.0;   
 x = linspace(-wafer_length/2,wafer_length/2,N); 
 y = linspace(-wafer_length/2,wafer_length/2,N); 
 xx = meshgridx(x,y) ;  
 yy = meshgridy(x,y) ;  
 wafer_Z_thickness = wafer_RMS_t*randnmatrix(N,N);  
 wafer_F_thickness = exp(-(xx^2/(wafer_clx_thickness^2/2)+yy^2/(wafer_cly_thickness^2/2))); 
 wafer_uniformity_thickness = real( 2/sqrt(pi)*wafer_length/N/sqrt(wafer_clx_thickness)/sqrt(wafer_cly_thickness)*invfft(fft(wafer_Z_thickness,1,0)*fft(wafer_F_thickness,1,0), 1, 0)  );    
 wafer_Z_width = wafer_RMS_w*randnmatrix(N,N);  
 wafer_F_width = exp(-(xx^2/(wafer_clx_width^2/2)+yy^2/(wafer_cly_width^2/2))); 
 wafer_uniformity_width = real( 2/sqrt(pi)*wafer_length/N/sqrt(wafer_clx_width)/sqrt(wafer_cly_width)*invfft(fft(wafer_Z_width,1,0)*fft(wafer_F_width,1,0), 1, 0)  );    
 mean_RMS_w = 5.0;     
 mean_RMS_t = 3.0;   
 wafer_uniformity_thickness = wafer_uniformity_thickness + randn(0,mean_RMS_t); 
 wafer_uniformity_width = wafer_uniformity_width + randn(0,mean_RMS_w); 
 #pass wafers to object 
 select("::Root Element");  
 set("wafer_uniformity_thickness", wafer_uniformity_thickness);  
 set("wafer_uniformity_width", wafer_uniformity_width);  
 set("N",N);  
 set("wafer_length",wafer_length);  
 select("::Root Element");
 set("setup script",' 
  ######################## high resolution interpolation for dies ################# 
  MC_grid = 5e-6;  
  die_span_x = 0.005; 
  die_span_y = 0.005; 
  MC_resolution_x = die_span_x/MC_grid;  
  MC_resolution_y = die_span_y/MC_grid;  
  die_num_x = floor(wafer_length/die_span_x); 
  die_num_y = floor(wafer_length/die_span_y); 
  die_num_total = die_num_x*die_num_y; 
  x = linspace(-wafer_length/2,wafer_length/2,N); 
  y = linspace(-wafer_length/2,wafer_length/2,N); 
  j=selected_die; 
  die_min_x = -wafer_length/2+(j-1)*die_span_x -floor((j-1)/die_num_x)*wafer_length; 
  die_max_x = -wafer_length/2+j*die_span_x -floor((j-1)/die_num_x)*wafer_length; 
  die_min_y = wafer_length/2-ceil(j/die_num_y)*die_span_y; 
  die_max_y = wafer_length/2-(ceil(j/die_num_y)-1)*die_span_y; 
  x_die = linspace(die_min_x, die_max_x, MC_resolution_x); 
  y_die = linspace(die_min_y, die_max_y, MC_resolution_y); 
  die_xx = meshgridx(x_die,y_die) ;  
  die_yy = meshgridy(x_die,y_die) ;  
  MC_uniformity_thickness = interp(wafer_uniformity_thickness, x, y, x_die, y_die); # interpolation 
  MC_uniformity_width = interp(wafer_uniformity_width, x, y, x_die, y_die); # interpolation 
  select("::Root Element::MZI");  
  set("MC_uniformity_thickness",MC_uniformity_thickness);  
  set("MC_uniformity_width",MC_uniformity_width);  
  set("MC_resolution_x",MC_resolution_x);  
  set("MC_resolution_y",MC_resolution_y);  
  set("MC_grid",MC_grid);  
  set("MC_non_uniform",1);  
 '); 
 for (ii=1;  ii<=n_die; ii=ii+1) {   
  switchtodesign; 
  setnamed("ONA_1","peak analysis", "single");
  select("::Root Element");  
  set("selected_die",ii);  
  run;
  select("ONA_1");
  T=getresult("ONA_1","input 1/mode 1/transmission");
  wavelength = T.wavelength;
  if (kk==1) { mc1.addparameter("wavelength",wavelength);} 
  mc1.addattribute("run", getattribute( getresult("ONA_1", "input 1/mode 1/gain"), getattribute(getresult("ONA_1", "input 1/mode 1/gain")) ) );
  Gain_Data_input1(1:num_points, kk) = getattribute( getresult("ONA_1", "input 1/mode 1/gain"), getattribute(getresult("ONA_1", "input 1/mode 1/gain")) ); 
  switchtodesign; 
  kk = kk + 1;  
 }
}
?"Spectrum data for each input can be found in the Script Workspace tab:";
?"Gain_Data_input1"; 
?"Plot spectrums using script: plot(wavelength, Gain_Data_input#)";
visualize(mc1);
