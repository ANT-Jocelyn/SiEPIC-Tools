<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># for debugging: check if this script has been executed.
Script_SiEPIC_General=1

# Issue: This file is loaded at startup, when there is no layout selected. 
# thus it cannot get a technology

# Import KLayout Python API methods:
# Box, Point, Polygon, Text, Trans, LayerInfo, etc
from pya import *
from SiEPIC.utils import get_technology

class Waveguide(PCellDeclarationHelper):

  def __init__(self):
    # Important: initialize the super class
    super(Waveguide, self).__init__()
    # declare the parameters
    TECHNOLOGY = get_technology()
    self.param("path", self.TypeShape, "Path", default = Path([Point(0,0), Point(10,0), Point(10,10)], 0.5))
    self.param("radius", self.TypeDouble, "Radius", default = 5)
    self.param("width", self.TypeDouble, "Width", default = 0.5)
    self.param("adiab", self.TypeBoolean, "Adiabatic", default = False)
    self.param("bezier", self.TypeDouble, "Bezier Parameter", default = 0.35)
    self.param("layers", self.TypeList, "Layers", default = ['Waveguide'])
    self.param("widths", self.TypeList, "Widths", default =  [0.5])
    self.param("offsets", self.TypeList, "Offsets", default = [0])
    
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Waveguide_%s" % self.path
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return shape.is_path()

  def transformation_from_shape(self, layout, shape, layer):
    return Trans(Trans.R0,0,0)

  def parameters_from_shape(self, layout, shape, layer):
    self._param_values = []
    for pd in self._param_decls:
      self._param_values.append(pd.default)
    return self._param_values
        
  def produce_impl(self):

    from SiEPIC.utils import arc, arc_bezier, angle_vector, angle_b_vectors, inner_angle_b_vectors
    from math import cos, sin, pi, sqrt
    import pya
    TECHNOLOGY = get_technology()
    
    dbu = self.layout.dbu
    path = self.path*(1/dbu)
    if not (len(self.layers)==len(self.widths) and len(self.layers)==len(self.offsets) and len(self.offsets)==len(self.widths)):
      raise Exception("There must be an equal number of layers, widths and offsets")
    path.unique_points()
    for lr in range(0, len(self.layers)):
      
      layer = self.layout.layer(TECHNOLOGY[self.layers[lr]])
      
      width = float(self.widths[lr])/dbu
      offset = float(self.offsets[lr])/dbu
      #radius = self.radius/dbu + offset
      
      tpath = path.translate_from_center(offset)
      
      pts = tpath.get_points()
      wg_pts = [pts[0]]
      for i in range(1,len(pts)-1):
        turn = ((angle_b_vectors(pts[i]-pts[i-1],pts[i+1]-pts[i])+90)%360-90)/90
        radius = (self.radius/dbu + offset) if turn &gt; 0 else (self.radius/dbu - offset)

        pt_radius = radius
        
        dis = pts[i].distance(pts[i-1])
        if (i==1 and dis &lt; pt_radius):
          pt_radius = dis - TECHNOLOGY['dbu']
        elif (dis &lt; 2*pt_radius):
          pt_radius = dis/2
        
        dis = pts[i].distance(pts[i+1])
        if (i==len(pts)-2 and dis &lt; pt_radius):
          pt_radius = dis
        elif (dis &lt; 2*pt_radius):
          pt_radius = dis/2

        if(self.adiab):
          arc_pts = [Point(-pt_radius, pt_radius) + pt for pt in arc_bezier(pt_radius, 270, 270 + inner_angle_b_vectors(pts[i-1]-pts[i], pts[i+1]-pts[i]), self.bezier)]
        else:
          arc_pts = [Point(-pt_radius, pt_radius) + pt for pt in arc(pt_radius, 270, 270 + inner_angle_b_vectors(pts[i-1]-pts[i], pts[i+1]-pts[i]))]
        angle = angle_vector(pts[i]-pts[i-1])/90
        
        wg_pts += Path(arc_pts, width).transformed(Trans(angle, turn &lt; 0, pts[i])).get_points()

      wg_pts.append(pts[-1])
      wg_polygon = Path(wg_pts, width).simple_polygon()
      self.cell.shapes(layer).insert(wg_polygon)
      
#      if TECHNOLOGY['Waveguide'].to_s() == self.layers[lr]:
      if self.layout.layer(TECHNOLOGY['Waveguide']) == layer:
        waveguide_length = wg_polygon.area() / self.width * dbu**2
 #     waveguide_length = 1

    pts = path.get_points()
    LayerPinRecN = self.layout.layer(TECHNOLOGY['PinRec'])
    
    t1 = Trans(angle_vector(pts[0]-pts[1])/90, False, pts[0])
    self.cell.shapes(LayerPinRecN).insert(Path([Point(-50, 0), Point(50, 0)], self.width/dbu).transformed(t1))
    self.cell.shapes(LayerPinRecN).insert(Text("pin1", t1)).text_size = 0.4/dbu
    
    t = Trans(angle_vector(pts[-1]-pts[-2])/90, False, pts[-1])
    self.cell.shapes(LayerPinRecN).insert(Path([Point(-50, 0), Point(50, 0)], self.width/dbu).transformed(t))
    self.cell.shapes(LayerPinRecN).insert(Text("pin2", t)).text_size = 0.4/dbu


    LayerDevRecN = self.layout.layer(TECHNOLOGY['DevRec'])
    if TECHNOLOGY['technology_name'] == 'EBeam':
      # Compact model information
      angle_vec = angle_vector(pts[0]-pts[1])/90
      halign = 0 # left
      angle=0
      pt2=pts[0]
      pt3=pts[0]
      if angle_vec == 0: # horizontal
        halign = 2 # right
        angle=0
        pt2=pts[0] + Point(0, self.width/dbu)
        pt3=pts[0] + Point(0, -self.width/dbu)
      if angle_vec == 2: # horizontal
        halign = 0 # left
        angle = 0
        pt2=pts[0] + Point(0, self.width/dbu)
        pt3=pts[0] + Point(0, -self.width/dbu)
      if angle_vec == 1: # vertical
        halign = 2 # right
        angle = 1
        pt2=pts[0] + Point(self.width/dbu,0)
        pt3=pts[0] + Point(-self.width/dbu,0)
      if angle_vec == -1: # vertical
        halign = 0 # left
        angle = 1
        pt2=pts[0] + Point(self.width/dbu,0)
        pt3=pts[0] + Point(-self.width/dbu,0)
        
      t = Trans(angle, False, pts[0]) 
      text = Text ('Lumerical_INTERCONNECT_library=Design kits/ebeam', t)
      text.halign=halign
      shape = self.cell.shapes(LayerDevRecN).insert(text)
      shape.text_size = 0.1/dbu
      t = Trans(angle, False, pt2)
      text = Text ('Lumerical_INTERCONNECT_component=ebeam_wg_integral_1550', t)
      text.halign=halign
      shape = self.cell.shapes(LayerDevRecN).insert(text)
      shape.text_size = 0.1/dbu
      t = Trans(angle, False, pt3)
      pts_txt = str([ [round(p.to_dtype(dbu).x,3), round(p.to_dtype(dbu).y,3)] for p in pts ]).replace(', ',',')
      text = Text ( \
        'Spice_param:wg_length=%.3fu wg_width=%.3fu points=%s radius=%s' %\
          (waveguide_length, self.width, pts_txt,self.radius ), t )
      text.halign=halign
      shape = self.cell.shapes(LayerDevRecN).insert(text)
      shape.text_size = 0.1/dbu

    if self.cell.shapes(self.layout.guiding_shape_layer()).is_empty():
      self.cell.shapes(self.layout.guiding_shape_layer()).insert(Path(path.get_points(), 0))
    
class LumericalINTERCONNECT_Laser(PCellDeclarationHelper):
  """
  The PCell declaration for the LumericalINTERCONNECT Optical Network Analyzer.
  This configures the swept tunable laser
  
  Ultimately want to generate Spice output such as:
  
  .ona input_unit=wavelength input_parameter=center_and_range center=1550e-9
  + range=100e-9 start=3 stop=4 number_of_points=1000 orthogonal_identifier=1
  + label=TE peak_analysis=disable number_of_peaks=8 peak_at_maximum=9
  + peak_threshold=0 peak_excursion=11 pit_excursion=12 fwhm_excursion=13
  + minimum_loss=14 sensitivity=-200 analysis_type=scattering_data
  + multithreading=automatic number_of_threads=1 input(1)=X_GC1,opt_fiber
  + output=X_GC2,opt_fiber

  
  """
  def __init__(self):
    # Important: initialize the super class
    super(LumericalINTERCONNECT_Laser, self).__init__()
    # declare the parameters
    self.param("wavelength_start", self.TypeDouble, "Start Wavelength (nm)", default = 1500)
    self.param("wavelength_stop", self.TypeDouble, "Stop Wavelength (nm)", default = 1600)
    self.param("npoints", self.TypeInt, "Number of points", default = 2000)     
    self.param("orthogonal_identifier", self.TypeInt, "Orthogonal identifier (1=TE, 2=TM)", default = 1)     
    self.param("ignoreOpticalIOs", self.TypeInt, "Ignore optical IOs in simulations (1=Ignore, 0=Include)", default = 0)
    self.param("s", self.TypeShape, "", default = DPoint(0, 0))

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    from SiEPIC.utils import layout_pgtext, get_technology
    TECHNOLOGY = get_technology()
    ly = self.layout
    shapes = self.cell.shapes
    dbu = self.layout.dbu
    
    LayerINTERCONNECT = ly.layer(TECHNOLOGY['Lumerical'])

    # Draw the laser
    width = 60/dbu
    height = 40/dbu
    shapes(LayerINTERCONNECT).insert(Box(-width/2, -height/2, width/2, height/2))
    
    shapes(LayerINTERCONNECT).insert(Text("Tunable Laser", Trans(Trans.R0,-width/2+3/dbu, height/2-4/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(Text("Wavelength range: %4.3f - %4.3f nm" % (self.wavelength_start, self.wavelength_stop), Trans(Trans.R0,-width/2+3/dbu, height/2-8/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(Text ("Number of points: %s" % (self.npoints), Trans(Trans.R0,-width/2+3/dbu, height/2-12/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(Text("Ignore optical IOs in simulations: %s" % (self.ignoreOpticalIOs), Trans(Trans.R0,-width/2+3/dbu, height/2-16/dbu))).text_size = 1.5/dbu
    # Add a polygon text description
    layout_pgtext(self.cell, TECHNOLOGY['Text'], -width/2*dbu+3, -height/2*dbu+2, "Number of points: %s" % (self.npoints), 2.2)
    layout_pgtext(self.cell, TECHNOLOGY['Text'], -width/2*dbu+3, -height/2*dbu+5, "Wavelength range: %4.3f - %4.3f nm" % (self.wavelength_start, self.wavelength_stop), 2.2)

class LumericalINTERCONNECT_Detector(PCellDeclarationHelper):
  """
  The PCell declaration for the LumericalINTERCONNECT Optical Network Analyzer.
  This configures the detector  
  """
  def __init__(self):
    # Important: initialize the super class
    super(LumericalINTERCONNECT_Detector, self).__init__()
    detector_number = 1
      
    # declare the parameters
    self.param("number", self.TypeInt, "Detector number", default = detector_number)     
    self.param("s", self.TypeShape, "", default = DPoint(0, 0))

  def can_create_from_shape_impl(self):
    return False

  def coerce_parameters_impl(self):
    pass
           
  def produce_impl(self):
    from SiEPIC.utils import layout_pgtext, get_technology
    TECHNOLOGY = get_technology()
    ly = self.layout
    shapes = self.cell.shapes
    dbu = self.layout.dbu
    
    LayerINTERCONNECT = ly.layer(TECHNOLOGY['Lumerical'])

    # Draw the outline
    width = 60/dbu
    height = 40/dbu
    shapes(LayerINTERCONNECT).insert(Box(-width/2, -height/2, width/2, height/2))

    shapes(LayerINTERCONNECT).insert(Text("Detector", Trans(-width/2+3/dbu, height/2-4/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(Text("Detector Number: %s" % (self.number), Trans(-width/2+3/dbu, height/2-8/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(Text("LumericalINTERCONNECT_Detector %s" % (self.number), Trans(0,0))).text_size = 0.1/dbu

    # Add a polygon text description
    layout_pgtext(self.cell, TECHNOLOGY['Text'], -width/2*dbu+3, -height/2*dbu+2, "Number: %s" % (self.number), 2.2)

class SiEPIC_General(Library):
  def __init__(self):
    library = 'SiEPIC General'
    print("Initializing '%s' Library." % library)

    self.description = "Laser, Detector, Waveguides"

    #import os
    #self.layout().read(os.path.join(os.path.dirname(os.path.realpath(__file__)), "SiEPIC-GSiP.gds"))
    #[self.layout().rename_cell(i, self.layout().cell_name(i).replace('_', ' ')) for i in range(0, self.layout().cells())]
    
    self.layout().register_pcell("Lumerical INTERCONNECT Laser", LumericalINTERCONNECT_Laser())
    self.layout().register_pcell("Lumerical INTERCONNECT Detector", LumericalINTERCONNECT_Detector())
    self.layout().register_pcell("Waveguide", Waveguide())
    
    # Register us the library with the technology name
    # If a library with that name already existed, it will be replaced then.
    self.register(library)

#    if int(Application.instance().version().split('.')[1]) &gt; 24:
      # KLayout v0.25 introduced technology variable:
#      self.technology=technology

    
SiEPIC_General()
 </text>
</klayout-macro>
