<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>
import SiEPIC, pya

'''
#################################################################################

This file is useful to use when debugging code. Breakpoints do not get registered
from within the module. To test code, define it in this file and import all modules 
explicitly. The changes will persist as modules are Singleton-like (only imported once).

Run to redefine functions/class methods

#################################################################################

Example 1:

def arc_test():
  return [pya.Point(0,0)]

from SiEPIC import utils
utils.arc = arc_test

*run macro*
*continue using Klayout as normal*

#################################################F################################
'''

if 1:
    import sys
    print (sys.version[0])
    if int(sys.version[0]) &gt; 2:
      from importlib import reload
    SiEPIC = reload(SiEPIC)
    SiEPIC.extend = reload(SiEPIC.extend)
    SiEPIC._globals = reload(SiEPIC._globals)
    SiEPIC.core = reload(SiEPIC.core)
    SiEPIC.examples = reload(SiEPIC.examples)
    SiEPIC.lumerical = reload(SiEPIC.lumerical)
    SiEPIC.lumerical.fdtd = reload(SiEPIC.lumerical.fdtd)
    SiEPIC.lumerical.interconnect = reload(SiEPIC.lumerical.interconnect)
    SiEPIC.scripts = reload(SiEPIC.scripts)
    SiEPIC.utils = reload(SiEPIC.utils)
    SiEPIC.setup = reload(SiEPIC.setup)
    print('Reloaded SiEPIC')


print ("***")

if 1:
  from SiEPIC import scripts  
  scripts.layout_check(verbose=True)


  
if 0:
  import os, fnmatch
  dir_path = pya.Application.instance().application_data_path()
  tech_name = 'GSiP'
  matches = []
  for root, dirnames, filenames in os.walk(dir_path, followlinks=True):
      for filename in fnmatch.filter(filenames, '*' + tech_name + '.lyp'):
          matches.append(os.path.join(root, filename))
  print(matches)
  

if 0:
  from SiEPIC.utils import get_layout_variables
  TECHNOLOGY, lv, ly, cell = get_layout_variables()

  #pins = cell.find_pins()
  #print (pins)

  if 0:
    print ("* find_components():" )
    components = cell.find_components (verbose=True)
    print ("* Display list of components:" )
    [c.display() for c in components]

  if 0:
    print ("* identify_nets():" )
    nets, components = cell.identify_nets (verbose=True)
    print ("* Display list of components:" )
    [c.display() for c in components]
    print ("* Display list of nets:" )
    [n.display() for n in nets]

  if 0:
    text_subckt, text_main, detector_nets = cell.spice_netlist_export(verbose=True)
    print(text_main)
    print(text_subckt)

  
  #from SiEPIC.core import WaveguideGUI, MonteCarloGUI, CalibreGUI, Net, Component
  #from SiEPIC import _globals
  #from SiEPIC.netlist import find_all_components


# bug in KLayout 0.25  
if 0:  
    lv = pya.Application.instance().main_window().current_view()
    ly = lv.active_cellview().layout() 
    cell = lv.active_cellview().cell
    
    LayerN=ly.layer(pya.LayerInfo('Text'))
    pya.Trans(pya.Trans.R0,10000,10000)
    pya.Trans(10000,10000)
#    cell.shapes(LayerN).insert(pya.Text ("elec1a", pya.Trans(10000,10000)))
    cell.shapes(LayerN).insert(pya.Text ("elec1a", pya.Trans(pya.Trans.R0,10000,10000)))


# Verification tests:

# test Component.has_compactmodel()
if 0:
  from SiEPIC.utils import get_layout_variables
  TECHNOLOGY, lv, ly, cell = get_layout_variables()

  if 0:
    print ("* find_components():" )
    components = cell.find_components ()
    print ("* Display list of components:" )
    [c.display() for c in components]
  if 0:
    text_subckt, text_main, detector_nets = cell.spice_netlist_export(verbose=True)
    print(text_main)
    print(text_subckt)
  if 1:
    print ("* find_components()" )
    components = cell.find_components ()
    print ("* Display list of components" )

    if not all([c.has_model() for c in components]):
      # missing models, find which one
      components_havemodels = [[c.has_model(), c.component, c.instance] for c in components]
      missing_models = []
      for c in components_havemodels:
        if c[0] == False:
          missing_models.append([c[1],c[2]])
      missing = ("We have %s component(s) missing models, as follows: %s" % (len(missing_models), missing_models))
      v = pya.MessageBox.warning("Errors", missing, pya.MessageBox.Ok)
      
  </text>
</klayout-macro>
